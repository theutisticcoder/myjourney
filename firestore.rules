/**
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership security model. All data is
 * hierarchically organized under a user's unique ID, ensuring that a user can
 * only ever access their own information. Unauthorized access to other users'
 * data is strictly prohibited.
 *
 * Data Structure:
 * The data is structured in a clear hierarchy to facilitate path-based security:
 * - /userAccounts/{userAccountId}: Stores the root profile for a user.
 * - /userAccounts/{userAccountId}/sessions/{sessionId}: A subcollection for workout sessions.
 * - /userAccounts/{userAccountId}/sessions/{sessionId}/chapters/{chapterId}: A subcollection for story chapters within a session.
 * This nesting allows ownership to be inferred directly from the document path,
 * which is efficient and secure.
 *
 * Key Security Decisions:
 * - Default Deny: All paths are closed by default. Access is only granted through explicit `allow` statements.
 * - Strict Ownership: All read and write operations are gated by an ownership check, comparing the requesting user's UID (`request.auth.uid`) with the `userAccountId` in the document path.
 * - No User Listing: It is not possible to list all documents in the `/userAccounts` collection, preventing enumeration of all application users.
 * - Relational Integrity: On creation, documents must contain an ID field that correctly references their parent in the path (e.g., a Session document must have a `userAccountId` field matching the path). This field is then enforced as immutable on update.
 *
 * Denormalization for Authorization:
 * This ruleset relies on path-based security, which is a form of structural denormalization.
 * By nesting a user's private data (sessions, chapters) under their unique
 * `/userAccounts/{userAccountId}` path, we avoid the need for slow and costly `get()`
 * calls in our rules to verify ownership. The ownership is part of the path itself.
 *
 * Structural Segregation:
 * The design segregates each user's data into its own document tree. This clear
 * separation allows for simple, powerful rules to be applied to entire subcollections
 * at once, guaranteeing that a user's session data can never be queried or accessed
 * by another user.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // -------------------------------------------------------------------------
    // Helper Functions
    // -------------------------------------------------------------------------

    /**
     * Returns true if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Returns true if the authenticated user's UID matches the provided userId.
     * This is the primary function for enforcing data ownership.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }
    
    /**
     * Returns true if the user is the owner and the document already exists.
     * Used for safe update and delete operations.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * Validates fields critical for creating a user's own account document.
     * Ensures the document ID matches the user's auth UID.
     */
    function isCreatingOwnAccount(userId) {
      let incomingData = request.resource.data;
      return incomingData.id == userId;
    }

    /**
     * Validates that critical, immutable fields are not changed on update.
     */
    function isUpdatingOwnAccount() {
      let incomingData = request.resource.data;
      let existingData = resource.data;
      return (!('id' in incomingData) || incomingData.id == existingData.id) &&
             (!('googleId' in incomingData) || incomingData.googleId == existingData.googleId);
    }

    /**
     * Validates the relational integrity of a new Session document.
     */
    function hasValidSessionData(userAccountId) {
      return request.resource.data.userId == userAccountId;
    }
    
    /**
     * Ensures the ownership link of a Session document is immutable.
     */
    function isSessionDataImmutable() {
        let incomingData = request.resource.data;
        let existingData = resource.data;
        return !('userId' in incomingData) || incomingData.userId == existingData.userId;
    }
    
    /**
     * Validates the relational integrity of a new Chapter document.
     */
    function hasValidChapterData(sessionId) {
      return request.resource.data.sessionId == sessionId;
    }
    
    /**
     * Ensures the ownership link of a Chapter document is immutable.
     */
    function isChapterDataImmutable() {
        let incomingData = request.resource.data;
        let existingData = resource.data;
        return !('sessionId' in incomingData) || incomingData.sessionId == existingData.sessionId;
    }

    // -------------------------------------------------------------------------
    // Collection Rules
    // -------------------------------------------------------------------------

    /**
     * @description Manages user account documents. Users can create, read, and
     *              update their own account, but cannot see or list others.
     * @path /userAccounts/{userAccountId}
     * @allow (create) An authenticated user can create their own account document.
     * @deny (list) A user cannot list all user accounts in the database.
     * @principle Restricts access to a user's own data tree and allows self-creation of a root user document.
     */
    match /userAccounts/{userAccountId} {
      allow get: if isOwner(userAccountId);
      allow list: if false;
      allow create: if isOwner(userAccountId) && isCreatingOwnAccount(userAccountId);
      allow update: if isExistingOwner(userAccountId) && isUpdatingOwnAccount();
      allow delete: if isExistingOwner(userAccountId);

      /**
       * @description Manages user workout sessions. A user has full control
       *              over their own sessions.
       * @path /userAccounts/{userAccountId}/sessions/{sessionId}
       * @allow (create) An authenticated user can create a new session in their own account.
       * @deny (get) A user cannot read a session belonging to another user.
       * @principle Enforces document ownership for all operations within a user-specific subcollection.
       */
      match /sessions/{sessionId} {
        allow get: if isOwner(userAccountId);
        allow list: if isOwner(userAccountId);
        allow create: if isOwner(userAccountId) && hasValidSessionData(userAccountId);
        allow update: if isExistingOwner(userAccountId) && isSessionDataImmutable();
        allow delete: if isExistingOwner(userAccountId);

        /**
         * @description Manages story chapters within a session. A user has
         *              full control over chapters in their own sessions.
         * @path /userAccounts/{userAccountId}/sessions/{sessionId}/chapters/{chapterId}
         * @allow (list) An authenticated user can list all chapters for their own session.
         * @deny (update) A user cannot update a chapter in another user's session.
         * @principle Extends parent document ownership rules to a nested subcollection.
         */
        match /chapters/{chapterId} {
          allow get: if isOwner(userAccountId);
          allow list: if isOwner(userAccountId);
          allow create: if isOwner(userAccountId) && hasValidChapterData(sessionId);
          allow update: if isExistingOwner(userAccountId) && isChapterDataImmutable();
          allow delete: if isExistingOwner(userAccountId);
        }
      }
    }
  }
}
